#!/usr/bin/env python3
"""
Construction Zone Generator - Simulation Scenario Generator for Construction Zones

Hierarchical Structure:
  Level 1: create_scene_from_bbox     - Input center coords + size, generate SUMO map
  Level 2: create_zone_from_coords    - Input start/end lat/lon, create construction zone config
  Level 3: create_zones_from_tomtom   - Fetch real construction zone data from TomTom API

Each level builds upon the previous one.

Usage:
    # Level 1: Randomly generate N construction zone configs
    python construction_zone_generator.py random --center 42.28,-83.74 --size 500 --num 5

    # Level 2: Generate from start/end coordinates
    python construction_zone_generator.py coords --start 42.280,-83.738 --end 42.281,-83.736

    # Level 3: Fetch from TomTom API
    python construction_zone_generator.py tomtom --api-key YOUR_KEY --center 42.28,-83.74 --size 1000
"""

import os
import sys
import json
import math
import random
import argparse
import subprocess
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, asdict

import yaml
import sumolib

# Load .env file
def load_dotenv():
    """Load environment variables from .env file"""
    env_file = Path(__file__).parent / ".env"
    if env_file.exists():
        with open(env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ.setdefault(key.strip(), value.strip())

load_dotenv()

# Try to import osmnx (for map download)
try:
    import osmnx as ox
    ox.settings.all_oneway = True
    HAS_OSMNX = True
except ImportError:
    HAS_OSMNX = False
    print("Warning: osmnx not installed. Map download will not be available.")


# =============================================================================
# Data Structures
# =============================================================================

@dataclass
class BoundingBox:
    """Geographic bounding box"""
    center_lat: float
    center_lon: float
    size_meters: float  # Side length (meters)

    @property
    def north(self) -> float:
        return self.center_lat + self._lat_offset()

    @property
    def south(self) -> float:
        return self.center_lat - self._lat_offset()

    @property
    def east(self) -> float:
        return self.center_lon + self._lon_offset()

    @property
    def west(self) -> float:
        return self.center_lon - self._lon_offset()

    def _lat_offset(self) -> float:
        earth_radius = 6371000
        return (self.size_meters / 2 / earth_radius) * (180 / math.pi)

    def _lon_offset(self) -> float:
        earth_radius = 6371000
        lat_rad = self.center_lat * math.pi / 180
        return (self.size_meters / 2 / earth_radius) * (180 / math.pi) / math.cos(lat_rad)

    def contains(self, lat: float, lon: float) -> bool:
        return self.south <= lat <= self.north and self.west <= lon <= self.east


@dataclass
class ConstructionZoneSpec:
    """Construction zone specification"""
    id: str
    start_lat: float
    start_lon: float
    end_lat: float
    end_lon: float
    description: str = ""
    lanes_to_close: List[int] = None

    def __post_init__(self):
        if self.lanes_to_close is None:
            self.lanes_to_close = [0]


@dataclass
class SUMOMatch:
    """SUMO map matching result (single edge)"""
    edge_id: str
    lane_id: str
    start_pos: float
    end_pos: float
    lane_count: int


@dataclass
class MultiEdgeMatch:
    """Multi-edge matching result (for construction zones spanning multiple roads)"""
    edges: List[SUMOMatch]  # Ordered list of edges
    total_length: float  # Total length of construction zone

    @property
    def edge_ids(self) -> List[str]:
        return [e.edge_id for e in self.edges]

    @property
    def is_single_edge(self) -> bool:
        return len(self.edges) == 1


# =============================================================================
# Level 1: Scene Creation (Center Coords + Range â†’ SUMO Map)
# =============================================================================

class SceneBuilder:
    """Scene Builder - Create SUMO simulation scene from geographic coordinates"""

    def __init__(self, output_base_dir: str = None):
        self.output_base_dir = Path(output_base_dir or Path(__file__).parent / "scenes")
        self.output_base_dir.mkdir(parents=True, exist_ok=True)

    def create_scene(
        self,
        bbox: BoundingBox,
        scene_name: str = None,
    ) -> Path:
        """
        Create simulation scene

        Args:
            bbox: Bounding box
            scene_name: Scene name (auto-generated by default)

        Returns:
            Scene directory path
        """
        if not HAS_OSMNX:
            raise RuntimeError("osmnx is required for map download. Install with: pip install osmnx")

        # Generate scene name
        if scene_name is None:
            scene_name = f"scene_{bbox.center_lat:.4f}_{bbox.center_lon:.4f}_{int(bbox.size_meters)}"

        scene_dir = self.output_base_dir / scene_name
        scene_dir.mkdir(parents=True, exist_ok=True)

        print(f"Creating scene: {scene_name}")
        print(f"  Center: ({bbox.center_lat:.5f}, {bbox.center_lon:.5f})")
        print(f"  Size: {bbox.size_meters}m x {bbox.size_meters}m")

        # Step 1: Download OSM data
        osm_file = self._download_osm(bbox, scene_dir)

        # Step 2: Convert to SUMO network
        net_file = self._convert_to_sumo(osm_file, scene_dir)

        # Step 3: Generate SUMO config files
        self._create_sumo_config(scene_dir, net_file)

        # Step 4: Save metadata
        self._save_metadata(scene_dir, bbox)

        print(f"Scene created: {scene_dir}")
        return scene_dir

    def _download_osm(self, bbox: BoundingBox, scene_dir: Path) -> Path:
        """Download OSM data"""
        print("  Downloading OSM data...")

        osm_file = scene_dir / "map.osm"

        # Download road network using osmnx
        graph = ox.graph_from_point(
            (bbox.center_lat, bbox.center_lon),
            dist=bbox.size_meters / 2,
            network_type="drive",
            simplify=False,
            retain_all=True,
            truncate_by_edge=True
        )

        # Save as OSM format
        ox.save_graph_xml(graph, osm_file)
        print(f"  OSM saved: {osm_file}")

        return osm_file

    def _convert_to_sumo(self, osm_file: Path, scene_dir: Path) -> Path:
        """Convert OSM to SUMO network"""
        print("  Converting to SUMO network...")

        net_file = scene_dir / "map.net.xml"

        cmd = [
            "netconvert",
            "--osm-files", str(osm_file),
            "--output", str(net_file),
            "--ramps.guess", "true",
            "--roundabouts.guess", "true",
            "--tls.guess", "true",
            "--geometry.remove", "true",
            "--junctions.join", "true",
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"  Warning: netconvert stderr: {result.stderr[:500]}")

        if not net_file.exists():
            raise RuntimeError(f"Failed to create SUMO network: {net_file}")

        print(f"  SUMO network: {net_file}")
        return net_file

    def _create_sumo_config(self, scene_dir: Path, net_file: Path):
        """Generate SUMO config files"""
        # Create empty route file
        route_file = scene_dir / "routes_empty.rou.xml"
        route_file.write_text('''<?xml version="1.0" encoding="UTF-8"?>
<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://sumo.dlr.de/xsd/routes_file.xsd">
</routes>
''')

        # Create SUMO config
        config_file = scene_dir / "simulation_no_traffic.sumocfg"
        config_content = f'''<?xml version="1.0" encoding="UTF-8"?>
<configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://sumo.dlr.de/xsd/sumoConfiguration.xsd">
    <input>
        <net-file value="{net_file.name}"/>
        <route-files value="{route_file.name}"/>
    </input>
    <time>
        <begin value="0"/>
        <end value="3600"/>
        <step-length value="0.1"/>
    </time>
    <processing>
        <lateral-resolution value="0.8"/>
    </processing>
</configuration>
'''
        config_file.write_text(config_content)
        print(f"  SUMO config: {config_file}")

    def _save_metadata(self, scene_dir: Path, bbox: BoundingBox):
        """Save scene metadata"""
        metadata = {
            "center": [bbox.center_lat, bbox.center_lon],
            "size_meters": bbox.size_meters,
            "bounds": {
                "north": bbox.north,
                "south": bbox.south,
                "east": bbox.east,
                "west": bbox.west,
            }
        }

        metadata_file = scene_dir / "metadata.json"
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)


# =============================================================================
# Level 2: Coordinates to Construction Zone Config
# =============================================================================

class ZoneConfigGenerator:
    """Zone Config Generator - Generate TeraSim config from coordinates"""

    def __init__(self, scene_dir: str):
        self.scene_dir = Path(scene_dir).resolve()  # Convert to absolute path
        self.net_file = self.scene_dir / "map.net.xml"

        if not self.net_file.exists():
            raise FileNotFoundError(f"SUMO network not found: {self.net_file}")

        self.net = sumolib.net.readNet(str(self.net_file))
        self.output_dir = self.scene_dir / "outputs"
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def create_zone_config(
        self,
        zone: ConstructionZoneSpec,
        run_time: int = 10,
        gui: bool = False,
    ) -> Optional[Path]:
        """
        Create construction zone config from coordinates (supports multi-edge)

        Args:
            zone: Construction zone specification
            run_time: Simulation duration (seconds)
            gui: Enable GUI

        Returns:
            Config file path, None if matching failed
        """
        # Match to SUMO network (multi-edge)
        multi_match = self._match_to_network_multi(zone)
        if multi_match is None:
            print(f"  Zone {zone.id}: Failed to match to network")
            return None

        # Generate config (supports multi-edge)
        config = self._build_config_multi(zone, multi_match, run_time, gui)

        # Save config
        config_file = self.output_dir / f"config_{zone.id}.yaml"
        with open(config_file, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, allow_unicode=True)

        print(f"  Generated config: {config_file.name}")
        print(f"    Edges: {len(multi_match.edges)}, Total length: {multi_match.total_length:.1f}m")

        return config_file

    def _match_to_network_multi(
        self,
        zone: ConstructionZoneSpec,
        max_distance: float = 100.0,
    ) -> Optional[MultiEdgeMatch]:
        """
        Match coordinates to SUMO network (supports multi-edge)

        Uses shortest path algorithm to find all edges from start to end
        """
        # Convert start and end coordinates
        start_x, start_y = self.net.convertLonLat2XY(zone.start_lon, zone.start_lat)
        end_x, end_y = self.net.convertLonLat2XY(zone.end_lon, zone.end_lat)

        # Find nearest edge to start point
        start_edges = self.net.getNeighboringEdges(start_x, start_y, max_distance)
        if not start_edges:
            print(f"  No edge found near start point")
            return None

        start_edges = sorted(start_edges, key=lambda e: e[1])
        start_edge = None
        for e, d in start_edges:
            if e.getFunction() != "internal" and e.getLaneNumber() >= 2:
                start_edge = e
                break

        if start_edge is None:
            print(f"  No valid start edge (need >= 2 lanes)")
            return None

        # Find nearest edge to end point
        end_edges = self.net.getNeighboringEdges(end_x, end_y, max_distance)
        if not end_edges:
            print(f"  No edge found near end point")
            return None

        end_edges = sorted(end_edges, key=lambda e: e[1])
        end_edge = None
        for e, d in end_edges:
            if e.getFunction() != "internal" and e.getLaneNumber() >= 2:
                end_edge = e
                break

        if end_edge is None:
            print(f"  No valid end edge (need >= 2 lanes)")
            return None

        print(f"  Start edge: {start_edge.getID()} (lanes={start_edge.getLaneNumber()})")
        print(f"  End edge: {end_edge.getID()} (lanes={end_edge.getLaneNumber()})")

        # If start and end are on the same edge
        if start_edge.getID() == end_edge.getID():
            return self._create_single_edge_match(start_edge, start_x, start_y, end_x, end_y)

        # Use SUMO shortest path finding
        path_edges = self._find_path(start_edge, end_edge)

        if not path_edges:
            print(f"  No path found between edges, using start edge only")
            return self._create_single_edge_match(start_edge, start_x, start_y, end_x, end_y)

        # Create match for each edge
        matches = []
        total_length = 0.0

        for i, edge in enumerate(path_edges):
            lane = edge.getLane(0)
            lane_length = lane.getLength()
            lane_count = edge.getLaneNumber()

            # Skip edges with insufficient lane count
            if lane_count < 2:
                print(f"    Skip {edge.getID()}: only {lane_count} lane(s)")
                continue

            # Calculate start and end positions on this edge
            if i == 0:
                # First edge: start from projected position
                lane_shape = lane.getShape()
                start_pos = self._get_position_on_lane(lane_shape, start_x, start_y)
                start_pos = max(5.0, start_pos)
                end_pos = lane_length - 5.0
            elif i == len(path_edges) - 1:
                # Last edge: end at projected position
                lane_shape = lane.getShape()
                start_pos = 5.0
                end_pos = self._get_position_on_lane(lane_shape, end_x, end_y)
                end_pos = min(lane_length - 5.0, end_pos)
            else:
                # Middle edge: cover entire length
                start_pos = 5.0
                end_pos = lane_length - 5.0

            # Ensure valid length
            if end_pos - start_pos < 20:
                print(f"    Skip {edge.getID()}: too short ({end_pos - start_pos:.1f}m)")
                continue

            match = SUMOMatch(
                edge_id=edge.getID(),
                lane_id=f"{edge.getID()}_0",
                start_pos=start_pos,
                end_pos=end_pos,
                lane_count=lane_count,
            )
            matches.append(match)
            total_length += (end_pos - start_pos)

            print(f"    Edge {edge.getID()}: {start_pos:.1f}m - {end_pos:.1f}m ({end_pos - start_pos:.1f}m)")

        if not matches:
            print(f"  No valid edges in path")
            return None

        print(f"  Total: {len(matches)} edges, {total_length:.1f}m")

        # Validate connectivity, remove disconnected edges
        if len(matches) > 1:
            matches = self._filter_disconnected_edges(matches)
            if matches:
                total_length = sum(m.end_pos - m.start_pos for m in matches)
                print(f"  After filtering: {len(matches)} edges, {total_length:.1f}m")

        return MultiEdgeMatch(edges=matches, total_length=total_length)

    def _find_path(self, start_edge, end_edge, max_depth: int = 100) -> List:
        """
        Use BFS to find path from start edge to end edge

        Args:
            start_edge: Start edge
            end_edge: End edge
            max_depth: Maximum search depth

        Returns:
            Edge list (in order), empty list if not found
        """
        from collections import deque

        if start_edge.getID() == end_edge.getID():
            return [start_edge]

        # BFS search
        queue = deque([(start_edge, [start_edge])])
        visited = {start_edge.getID()}

        while queue:
            current_edge, path = queue.popleft()

            if len(path) > max_depth:
                continue

            # Get successor edges
            to_node = current_edge.getToNode()
            for next_edge in to_node.getOutgoing():
                if next_edge.getFunction() == "internal":
                    continue

                if next_edge.getID() in visited:
                    continue

                new_path = path + [next_edge]

                if next_edge.getID() == end_edge.getID():
                    return new_path

                visited.add(next_edge.getID())
                queue.append((next_edge, new_path))

        # Try reverse search (direction might be opposite)
        queue = deque([(end_edge, [end_edge])])
        visited = {end_edge.getID()}

        while queue:
            current_edge, path = queue.popleft()

            if len(path) > max_depth:
                continue

            to_node = current_edge.getToNode()
            for next_edge in to_node.getOutgoing():
                if next_edge.getFunction() == "internal":
                    continue

                if next_edge.getID() in visited:
                    continue

                new_path = path + [next_edge]

                if next_edge.getID() == start_edge.getID():
                    # Reverse path
                    return list(reversed(new_path))

                visited.add(next_edge.getID())
                queue.append((next_edge, new_path))

        return []

    def _create_single_edge_match(self, edge, start_x, start_y, end_x, end_y) -> MultiEdgeMatch:
        """Create match for single edge"""
        lane = edge.getLane(0)
        lane_length = lane.getLength()
        lane_shape = lane.getShape()

        start_pos = self._get_position_on_lane(lane_shape, start_x, start_y)
        end_pos = self._get_position_on_lane(lane_shape, end_x, end_y)

        if start_pos > end_pos:
            start_pos, end_pos = end_pos, start_pos

        start_pos = max(5.0, start_pos)
        end_pos = min(lane_length - 5.0, end_pos)

        if end_pos - start_pos < 20:
            mid = (start_pos + end_pos) / 2
            start_pos = max(5.0, mid - 15)
            end_pos = min(lane_length - 5.0, mid + 15)

        match = SUMOMatch(
            edge_id=edge.getID(),
            lane_id=f"{edge.getID()}_0",
            start_pos=start_pos,
            end_pos=end_pos,
            lane_count=edge.getLaneNumber(),
        )

        return MultiEdgeMatch(edges=[match], total_length=end_pos - start_pos)

    def _match_to_network(
        self,
        zone: ConstructionZoneSpec,
        max_distance: float = 100.0,
    ) -> Optional[SUMOMatch]:
        """Match coordinates to SUMO network (single edge, backward compatible)"""
        result = self._match_to_network_multi(zone, max_distance)
        if result and result.edges:
            return result.edges[0]
        return None

    def _get_position_on_lane(
        self,
        lane_shape: List[Tuple[float, float]],
        x: float,
        y: float,
    ) -> float:
        """Calculate projected position of point on lane"""
        min_dist = float('inf')
        best_pos = 0.0
        cumulative_length = 0.0

        for i in range(len(lane_shape) - 1):
            x1, y1 = lane_shape[i]
            x2, y2 = lane_shape[i + 1]

            seg_len = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            if seg_len < 1e-6:
                cumulative_length += seg_len
                continue

            dx, dy = x2 - x1, y2 - y1
            t = max(0, min(1, ((x - x1) * dx + (y - y1) * dy) / (seg_len * seg_len)))

            proj_x = x1 + t * dx
            proj_y = y1 + t * dy
            dist = math.sqrt((x - proj_x)**2 + (y - proj_y)**2)

            if dist < min_dist:
                min_dist = dist
                best_pos = cumulative_length + t * seg_len

            cumulative_length += seg_len

        return best_pos

    def _filter_disconnected_edges(self, matches: List[SUMOMatch]) -> List[SUMOMatch]:
        """
        Filter out disconnected edges, keep only continuous portion from first edge

        Args:
            matches: List of matched edges

        Returns:
            Filtered list of continuous edges
        """
        if len(matches) <= 1:
            return matches

        # Start from first edge, check if each edge connects to previous
        connected = [matches[0]]

        for i in range(1, len(matches)):
            prev_edge_id = connected[-1].edge_id
            curr_edge_id = matches[i].edge_id

            # Get edge objects
            prev_edge = self.net.getEdge(prev_edge_id)
            curr_edge = self.net.getEdge(curr_edge_id)

            # Check connectivity: prev_edge's to_node == curr_edge's from_node
            prev_to_node = prev_edge.getToNode()
            curr_from_node = curr_edge.getFromNode()

            if prev_to_node.getID() == curr_from_node.getID():
                connected.append(matches[i])
            else:
                # Not connected, stop
                print(f"    Disconnected at {prev_edge_id} -> {curr_edge_id}")
                break

        return connected

    def _build_config_multi(
        self,
        zone: ConstructionZoneSpec,
        multi_match: MultiEdgeMatch,
        run_time: int,
        gui: bool,
    ) -> Dict[str, Any]:
        """Build TeraSim config (supports multi-edge)"""
        seed = random.randint(10000, 99999)

        # Generate lane_plan for each edge
        lane_plans = {}
        all_edge_ids = []

        for i, match in enumerate(multi_match.edges):
            edge_length = match.end_pos - match.start_pos

            # First edge has taper_in, last edge has taper_out
            if i == 0:
                taper_in = min(edge_length * 0.15, 10.0)
            else:
                taper_in = 0.0

            if i == len(multi_match.edges) - 1:
                taper_out = min(edge_length * 0.15, 10.0)
            else:
                taper_out = 0.0

            work = edge_length - taper_in - taper_out

            lane_plans[match.lane_id] = {
                "start": float(match.start_pos),
                "end": float(match.end_pos),
                "warning": 0.0,
                "taper_in": float(taper_in),
                "work": float(max(work, 10.0)),
                "taper_out": float(taper_out),
                "zone_spacing": {
                    "taper_in": 2.0,
                    "work": 2.0,
                    "taper_out": 2.0,
                },
                "work_zone_offset": 1.0,
            }
            all_edge_ids.append(match.edge_id)

        adversity_cfg = {
            "static": {
                "simple_urban_construction_zone": {
                    "_convert_": "all",
                    "_target_": "terasim_nde_nade.adversity.static.urban_construction_simple.SimpleUrbanConstructionAdversity",
                    "allow_exceed_lane_boundary": True,
                    "construction_type": "cone",
                    "edges": all_edge_ids,
                    "end_position": None,
                    "end_time": -1.0,
                    "lane_plans": lane_plans,
                    "lanes_to_close": zone.lanes_to_close,
                    "min_lane_length": 30.0,
                    "min_open_lanes": 1,
                    "spacing": 20.0,
                    "speed_limit_mph": None,
                    "start_position": None,
                    "start_time": 0.0,
                    "use_dynamic_spacing": False,
                    "work_zone_offset": 0.0,
                }
            }
        }

        config = {
            "seed": seed,
            "input": {
                "sumo_net_file": str(self.net_file),
                "sumo_config_file": str(self.scene_dir / "simulation_no_traffic.sumocfg"),
            },
            "output": {
                "dir": str(self.output_dir),
                "name": f"zone_{zone.id}",
                "aggregated_dir": "aggregated",
                "nth": zone.id,
            },
            "logging": {
                "levels": ["TRACE", "INFO"],
            },
            "simulator": {
                "class": "Simulator",
                "module": "terasim.simulator",
                "parameters": {
                    "gui_flag": gui,
                    "num_tries": 10,
                    "realtime_flag": False,
                    "sumo_output_file_types": ["fcd_all", "collision", "tripinfo"],
                    "sumo_seed": seed,
                },
            },
            "environment": {
                "class": "NADE",
                "module": "terasim_nde_nade.envs",
                "parameters": {
                    "run_time": run_time,
                    "warmup_time_lb": 0,
                    "warmup_time_ub": 1,
                    "log_flag": True,
                    "drive_rule": "righthand",
                    "MOBIL_lc_flag": True,
                    "stochastic_acc_flag": False,
                    "adversity_sampling_probability": 0.1,
                    "vehicle_factory": "terasim_nde_nade.vehicle.nde_vehicle_factory.NDEVehicleFactory",
                    "info_extractor": "terasim.logger.infoextractor.InfoExtractor",
                    "adversity_cfg": adversity_cfg,
                },
            },
        }

        return config

    def random_generate(
        self,
        num_configs: int = 5,
        min_length: float = 30.0,
        max_length: float = 100.0,
        run_time: int = 10,
        seed: int = None,
    ) -> List[Path]:
        """
        Randomly generate N construction zone configs

        Args:
            num_configs: Number of configs
            min_length: Minimum zone length (meters)
            max_length: Maximum zone length (meters)
            run_time: Simulation duration
            seed: Random seed

        Returns:
            List of generated config files
        """
        if seed is not None:
            random.seed(seed)

        print(f"\nGenerating {num_configs} random construction zone configs...")

        # Get all eligible edges
        eligible_edges = self._find_eligible_edges(min_length)

        if len(eligible_edges) < num_configs:
            print(f"Warning: Only {len(eligible_edges)} eligible edges found")
            num_configs = min(num_configs, len(eligible_edges))

        # Randomly select edges
        selected_edges = random.sample(eligible_edges, num_configs)

        config_files = []
        for i, (edge, lane_length) in enumerate(selected_edges):
            # Randomly generate zone position and length
            zone_length = random.uniform(min_length, min(max_length, lane_length * 0.6))
            max_start = lane_length - zone_length - 10
            start_pos = random.uniform(10, max(10, max_start))
            end_pos = start_pos + zone_length

            # Convert to lat/lon (for logging)
            lane = edge.getLane(0)
            shape = lane.getShape()

            # Create zone spec
            zone = ConstructionZoneSpec(
                id=f"random_{i:03d}",
                start_lat=0,  # No need for real coords, using SUMO position directly
                start_lon=0,
                end_lat=0,
                end_lon=0,
                description=f"Random zone on {edge.getID()}",
            )

            # Directly create match (skip coordinate matching)
            match = SUMOMatch(
                edge_id=edge.getID(),
                lane_id=f"{edge.getID()}_0",
                start_pos=start_pos,
                end_pos=end_pos,
                lane_count=edge.getLaneNumber(),
            )

            # Generate config
            config = self._build_config(zone, match, run_time, False)

            config_file = self.output_dir / f"config_random_{i:03d}.yaml"
            with open(config_file, 'w') as f:
                yaml.dump(config, f, default_flow_style=False, allow_unicode=True)

            config_files.append(config_file)
            print(f"  [{i+1}/{num_configs}] {edge.getID()}: {start_pos:.1f}m - {end_pos:.1f}m (length: {zone_length:.1f}m)")

        print(f"\nGenerated {len(config_files)} config files in {self.output_dir}")
        return config_files

    def _find_eligible_edges(self, min_length: float) -> List[Tuple[Any, float]]:
        """Find eligible edges"""
        eligible = []

        for edge in self.net.getEdges():
            # Skip internal edges
            if edge.getFunction() == "internal":
                continue

            # Check lane count
            if edge.getLaneNumber() < 2:
                continue

            # Check length
            lane = edge.getLane(0)
            length = lane.getLength()
            if length < min_length + 20:  # Need extra space
                continue

            eligible.append((edge, length))

        return eligible


# =============================================================================
# Level 3: TomTom API Integration
# =============================================================================

class TomTomIntegrator:
    """TomTom API Integrator - Fetch real construction zone data"""

    def __init__(self, api_key: str):
        self.api_key = api_key

    def fetch_construction_zones(
        self,
        bbox: BoundingBox,
    ) -> List[ConstructionZoneSpec]:
        """
        Fetch construction zone data from TomTom API

        Args:
            bbox: Bounding box

        Returns:
            List of construction zone specifications
        """
        import requests

        url = "https://api.tomtom.com/traffic/services/5/incidentDetails"

        bbox_str = f"{bbox.west},{bbox.south},{bbox.east},{bbox.north}"

        params = {
            "key": self.api_key,
            "bbox": bbox_str,
            "fields": "{incidents{type,geometry{type,coordinates},properties{id,iconCategory,magnitudeOfDelay,events{description,code},length,startTime,endTime}}}",
            "language": "en-US",
            "categoryFilter": "9",  # RoadWorks
            "timeValidityFilter": "present",
        }

        print(f"Fetching TomTom incidents from bbox: {bbox_str}")

        try:
            response = requests.get(url, params=params, timeout=30)
            response.raise_for_status()
            data = response.json()
        except Exception as e:
            print(f"TomTom API request failed: {e}")
            return []

        incidents = data.get("incidents", [])
        print(f"Found {len(incidents)} construction zone incidents")

        zones = []
        for incident in incidents:
            zone = self._parse_incident(incident)
            if zone:
                zones.append(zone)

        return zones

    def _parse_incident(self, incident: Dict) -> Optional[ConstructionZoneSpec]:
        """Parse TomTom incident"""
        try:
            props = incident.get("properties", {})
            geometry = incident.get("geometry", {})

            zone_id = props.get("id", "unknown")[:20]
            coords = geometry.get("coordinates", [])

            if not coords:
                return None

            # Get description
            events = props.get("events", [])
            description = events[0].get("description", "Construction") if events else "Construction"

            # Parse coordinates
            if geometry.get("type") == "LineString":
                start_lon, start_lat = coords[0]
                end_lon, end_lat = coords[-1]
            else:
                start_lon, start_lat = coords[0], coords[1] if len(coords) >= 2 else coords[0]
                length = props.get("length", 50)
                end_lon, end_lat = start_lon, start_lat

            return ConstructionZoneSpec(
                id=zone_id,
                start_lat=start_lat,
                start_lon=start_lon,
                end_lat=end_lat,
                end_lon=end_lon,
                description=description,
            )
        except Exception as e:
            print(f"Failed to parse incident: {e}")
            return None


# =============================================================================
# Main Entry: ConstructionZoneGenerator
# =============================================================================

class ConstructionZoneGenerator:
    """
    Construction Zone Generator - Unified Entry Point

    Supports three modes:
    1. random: Randomly generate N construction zone configs
    2. coords: Generate from start/end coordinates
    3. tomtom: Fetch real construction zones from TomTom API
    """

    def __init__(
        self,
        center_lat: float,
        center_lon: float,
        size_meters: float = 500,
        output_dir: str = None,
        scene_name: str = None,
    ):
        self.bbox = BoundingBox(center_lat, center_lon, size_meters)
        self.output_dir = Path(output_dir) if output_dir else Path(__file__).parent / "scenes"
        self.scene_name = scene_name

        self.scene_dir = None
        self.zone_generator = None

    def setup_scene(self, skip_if_exists: bool = True) -> Path:
        """
        Setup scene (download map)

        Args:
            skip_if_exists: Skip if scene already exists

        Returns:
            Scene directory path
        """
        scene_builder = SceneBuilder(str(self.output_dir))

        # Check if scene already exists
        if self.scene_name:
            potential_dir = self.output_dir / self.scene_name
            if potential_dir.exists() and (potential_dir / "map.net.xml").exists():
                if skip_if_exists:
                    print(f"Scene already exists: {potential_dir}")
                    self.scene_dir = potential_dir
                    self.zone_generator = ZoneConfigGenerator(str(self.scene_dir))
                    return self.scene_dir

        # Create new scene
        self.scene_dir = scene_builder.create_scene(self.bbox, self.scene_name)
        self.zone_generator = ZoneConfigGenerator(str(self.scene_dir))

        return self.scene_dir

    def use_existing_scene(self, scene_dir: str):
        """
        Use an existing scene

        Automatically extract bbox from scene:
        1. First try to read from metadata.json
        2. Otherwise calculate from SUMO network boundary
        """
        self.scene_dir = Path(scene_dir)
        net_file = self.scene_dir / "map.net.xml"

        if not net_file.exists():
            raise FileNotFoundError(f"No SUMO network in {scene_dir}")

        self.zone_generator = ZoneConfigGenerator(str(self.scene_dir))

        # Try to read bbox from metadata.json
        metadata_file = self.scene_dir / "metadata.json"
        if metadata_file.exists():
            try:
                with open(metadata_file, 'r') as f:
                    metadata = json.load(f)
                center = metadata.get("center", [])
                size = metadata.get("size_meters", 500)
                if len(center) == 2:
                    self.bbox = BoundingBox(center[0], center[1], size)
                    print(f"Loaded bbox from metadata: center=({center[0]:.5f}, {center[1]:.5f}), size={size}m")
                    return
            except Exception as e:
                print(f"Warning: Failed to load metadata.json: {e}")

        # Calculate bbox from SUMO network boundary
        net = self.zone_generator.net
        boundary = net.getBoundary()  # (minX, minY, maxX, maxY) in SUMO coordinates

        # Convert SUMO XY boundary to lat/lon
        min_lon, min_lat = net.convertXY2LonLat(boundary[0], boundary[1])
        max_lon, max_lat = net.convertXY2LonLat(boundary[2], boundary[3])

        # Calculate center point
        center_lat = (min_lat + max_lat) / 2
        center_lon = (min_lon + max_lon) / 2

        # Calculate size in meters
        earth_radius = 6371000
        lat_rad = center_lat * math.pi / 180
        lat_diff = max_lat - min_lat
        lon_diff = max_lon - min_lon

        lat_meters = lat_diff * (math.pi / 180) * earth_radius
        lon_meters = lon_diff * (math.pi / 180) * earth_radius * math.cos(lat_rad)
        size_meters = max(lat_meters, lon_meters)

        self.bbox = BoundingBox(center_lat, center_lon, size_meters)
        print(f"Calculated bbox from network: center=({center_lat:.5f}, {center_lon:.5f}), size={size_meters:.0f}m")

    def random_generate(
        self,
        num_configs: int = 5,
        min_length: float = 30.0,
        max_length: float = 100.0,
        run_time: int = 10,
        seed: int = None,
        run_simulation: bool = False,
    ) -> List[Path]:
        """
        Randomly generate N construction zone configs and optionally run simulations

        Args:
            num_configs: Number of configs to generate
            min_length: Minimum zone length
            max_length: Maximum zone length
            run_time: Simulation duration
            seed: Random seed
            run_simulation: Whether to run simulation

        Returns:
            List of config file paths
        """
        if self.zone_generator is None:
            raise RuntimeError("Call setup_scene() or use_existing_scene() first")

        configs = self.zone_generator.random_generate(
            num_configs=num_configs,
            min_length=min_length,
            max_length=max_length,
            run_time=run_time,
            seed=seed,
        )

        if run_simulation:
            self._run_simulations(configs)

        return configs

    def generate_from_coordinates(
        self,
        start_lat: float,
        start_lon: float,
        end_lat: float,
        end_lon: float,
        zone_id: str = "manual",
        run_time: int = 10,
        run_simulation: bool = False,
    ) -> Optional[Path]:
        """
        Generate construction zone from start/end coordinates

        Args:
            start_lat, start_lon: Start coordinates
            end_lat, end_lon: End coordinates
            zone_id: Zone ID
            run_time: Simulation duration
            run_simulation: Whether to run simulation

        Returns:
            Config file path
        """
        if self.zone_generator is None:
            raise RuntimeError("Call setup_scene() or use_existing_scene() first")

        zone = ConstructionZoneSpec(
            id=zone_id,
            start_lat=start_lat,
            start_lon=start_lon,
            end_lat=end_lat,
            end_lon=end_lon,
            description="Manual construction zone",
        )

        config = self.zone_generator.create_zone_config(zone, run_time)

        if config and run_simulation:
            self._run_simulations([config])

        return config

    def generate_from_tomtom(
        self,
        api_key: str,
        run_time: int = 10,
        run_simulation: bool = False,
    ) -> List[Path]:
        """
        Fetch construction zones from TomTom API and generate configs

        Args:
            api_key: TomTom API key
            run_time: Simulation duration
            run_simulation: Whether to run simulation

        Returns:
            List of config file paths
        """
        if self.zone_generator is None:
            raise RuntimeError("Call setup_scene() or use_existing_scene() first")

        # Fetch TomTom data
        tomtom = TomTomIntegrator(api_key)
        zones = tomtom.fetch_construction_zones(self.bbox)

        if not zones:
            print("No construction zones found from TomTom API")
            return []

        # Generate config for each zone (add index to avoid filename conflicts)
        configs = []
        for i, zone in enumerate(zones):
            # Add index to zone id to avoid duplicates
            zone.id = f"tomtom_{i:03d}"
            config = self.zone_generator.create_zone_config(zone, run_time)
            if config:
                configs.append(config)

        print(f"\nGenerated {len(configs)}/{len(zones)} configs from TomTom data")

        if configs and run_simulation:
            self._run_simulations(configs)

        return configs

    def _run_simulations(self, config_files: List[Path]):
        """Run simulations (includes visualization and Waymo conversion)"""
        # Import run functions
        try:
            from pipeline import run_simulation, convert_to_waymo, load_or_create_map_cache
            from visualizer import visualize_construction_zone_auto
        except ImportError:
            print("Warning: Could not import pipeline functions")
            return

        print(f"\nRunning {len(config_files)} simulations...")

        # Target output directory: urban_construcion_zone/outputs/
        base_output_dir = Path(__file__).parent / "outputs"
        base_output_dir.mkdir(parents=True, exist_ok=True)

        # Preload map cache (for Waymo conversion)
        base_scenario = None
        if self.scene_dir:
            base_scenario = load_or_create_map_cache(self.scene_dir)

        net_file = self.scene_dir / "map.net.xml" if self.scene_dir else None

        for i, config_file in enumerate(config_files):
            print(f"\n[{i+1}/{len(config_files)}] Running: {config_file.name}")
            try:
                # Step 1: Run simulation
                output_dir = run_simulation(config_file, gui_flag=False)

                # Get output name from config, build new output directory
                import yaml
                with open(config_file, 'r') as f:
                    cfg = yaml.safe_load(f)
                seed = cfg.get('seed', 0)
                zone_name = cfg.get('output', {}).get('name', 'zone')

                # New output directory format: outputs/<zone_name>_<seed>
                new_output_name = f"{zone_name}_{seed}"
                new_output_dir = base_output_dir / new_output_name

                # Move/copy output files to new directory
                if output_dir.exists():
                    import shutil
                    if new_output_dir.exists():
                        shutil.rmtree(new_output_dir)
                    shutil.copytree(output_dir, new_output_dir)
                    print(f"  Output copied to: {new_output_dir}")
                else:
                    new_output_dir = output_dir

                # Step 2: Visualization (auto mode: single image for short zones, segmented+interactive for long zones)
                fcd_file = new_output_dir / "fcd_all.xml"
                if fcd_file.exists() and net_file and net_file.exists():
                    vis_output = new_output_dir / "construction_zone.png"
                    try:
                        generated_files = visualize_construction_zone_auto(
                            net_file=str(net_file),
                            fcd_file=str(fcd_file),
                            output_file=str(vis_output),
                            segment_threshold=1000.0,  # Use segmented for zones > 1km
                            segment_length=500.0       # 500m per segment
                        )
                        if generated_files:
                            print(f"  Visualization: {len(generated_files)} files generated")
                            for f in generated_files:
                                print(f"    - {f.name}")
                    except Exception as e:
                        print(f"  Visualization failed: {e}")

                # Step 3: Waymo conversion
                if fcd_file.exists():
                    waymo_output = new_output_dir / "waymo_scenario.pb"
                    try:
                        convert_to_waymo(
                            fcd_file=fcd_file,
                            output_file=waymo_output,
                            base_scenario=base_scenario,
                            net_file=net_file if base_scenario is None else None
                        )
                        print(f"  Waymo: {waymo_output.name}")
                    except Exception as e:
                        print(f"  Waymo conversion failed: {e}")

                print(f"  Success! Output: {new_output_dir}")
            except Exception as e:
                print(f"  Failed: {e}")
                import traceback
                traceback.print_exc()


# =============================================================================
# CLI Entry Point
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Construction Zone Generator - Simulation Scenario Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Randomly generate 5 construction zone configs (using existing scene)
  python construction_zone_generator.py random --scene scenes/ann_arbor_whole --num 5

  # Create new scene and randomly generate configs
  python construction_zone_generator.py random --center 42.28,-83.74 --size 500 --num 5

  # Generate from coordinates
  python construction_zone_generator.py coords --scene scenes/ann_arbor_whole \\
      --start 42.280,-83.738 --end 42.281,-83.736

  # Fetch from TomTom API
  python construction_zone_generator.py tomtom --api-key YOUR_KEY --center 42.28,-83.74 --size 1000
        """
    )

    subparsers = parser.add_subparsers(dest="mode", help="Generation mode")

    # Random mode
    random_parser = subparsers.add_parser("random", help="Randomly generate construction zones")
    random_parser.add_argument("--scene", help="Existing scene directory")
    random_parser.add_argument("--center", help="Center coordinates (lat,lon)")
    random_parser.add_argument("--size", type=float, default=500, help="Bbox size in meters")
    random_parser.add_argument("--num", type=int, default=5, help="Number of configs to generate")
    random_parser.add_argument("--min-length", type=float, default=30, help="Min zone length")
    random_parser.add_argument("--max-length", type=float, default=100, help="Max zone length")
    random_parser.add_argument("--seed", type=int, help="Random seed")
    random_parser.add_argument("--run", action="store_true", help="Run simulations")

    # Coords mode
    coords_parser = subparsers.add_parser("coords", help="Generate from coordinates")
    coords_parser.add_argument("--scene", help="Existing scene directory (optional, will create if not provided)")
    coords_parser.add_argument("--start", required=True, help="Start coordinates (lat,lon)")
    coords_parser.add_argument("--end", required=True, help="End coordinates (lat,lon)")
    coords_parser.add_argument("--size", type=float, help="Scene size in meters (auto-calculated if not provided)")
    coords_parser.add_argument("--id", default="manual", help="Zone ID")
    coords_parser.add_argument("--run", action="store_true", help="Run simulation")

    # TomTom mode
    tomtom_parser = subparsers.add_parser("tomtom", help="Generate from TomTom API")
    tomtom_parser.add_argument("--api-key", help="TomTom API key (default: from .env TOMTOM_API_KEY)")
    tomtom_parser.add_argument("--scene", help="Existing scene directory")
    tomtom_parser.add_argument("--center", help="Center coordinates (lat,lon)")
    tomtom_parser.add_argument("--size", type=float, default=1000, help="Bbox size in meters")
    tomtom_parser.add_argument("--run", action="store_true", help="Run simulations")

    args = parser.parse_args()

    if args.mode is None:
        parser.print_help()
        return

    # Parse coordinates
    def parse_coords(s):
        parts = s.split(",")
        return float(parts[0]), float(parts[1])

    if args.mode == "random":
        if args.scene:
            gen = ConstructionZoneGenerator(0, 0)  # Placeholder coords
            gen.use_existing_scene(args.scene)
        elif args.center:
            lat, lon = parse_coords(args.center)
            gen = ConstructionZoneGenerator(lat, lon, args.size)
            gen.setup_scene()
        else:
            print("Error: Either --scene or --center is required")
            return

        gen.random_generate(
            num_configs=args.num,
            min_length=args.min_length,
            max_length=args.max_length,
            seed=args.seed,
            run_simulation=args.run,
        )

    elif args.mode == "coords":
        start_lat, start_lon = parse_coords(args.start)
        end_lat, end_lon = parse_coords(args.end)

        if args.scene:
            # Use existing scene
            gen = ConstructionZoneGenerator(0, 0)
            gen.use_existing_scene(args.scene)
        else:
            # Auto-create scene: calculate center and range
            center_lat = (start_lat + end_lat) / 2
            center_lon = (start_lon + end_lon) / 2

            # Calculate distance
            earth_radius = 6371000
            lat_diff = abs(end_lat - start_lat)
            lon_diff = abs(end_lon - start_lon)
            lat_rad = center_lat * math.pi / 180
            lat_meters = lat_diff * (math.pi / 180) * earth_radius
            lon_meters = lon_diff * (math.pi / 180) * earth_radius * math.cos(lat_rad)
            distance = math.sqrt(lat_meters**2 + lon_meters**2)

            # Scene size: 1.5x distance, minimum 500m
            size = args.size if args.size else max(500, int(distance * 1.5))
            print(f"Auto-calculated scene: center=({center_lat:.5f}, {center_lon:.5f}), size={size}m")

            gen = ConstructionZoneGenerator(center_lat, center_lon, size)
            gen.setup_scene()

        gen.generate_from_coordinates(
            start_lat, start_lon,
            end_lat, end_lon,
            zone_id=args.id,
            run_simulation=args.run,
        )

    elif args.mode == "tomtom":
        # Get API key: prefer command line argument, then environment variable
        api_key = args.api_key or os.environ.get("TOMTOM_API_KEY")
        if not api_key:
            print("Error: TomTom API key required. Use --api-key or set TOMTOM_API_KEY in .env")
            return

        if args.scene:
            gen = ConstructionZoneGenerator(0, 0)
            gen.use_existing_scene(args.scene)
        elif args.center:
            lat, lon = parse_coords(args.center)
            gen = ConstructionZoneGenerator(lat, lon, args.size)
            gen.setup_scene()
        else:
            print("Error: Either --scene or --center is required")
            return

        gen.generate_from_tomtom(
            api_key=api_key,
            run_simulation=args.run,
        )


if __name__ == "__main__":
    main()
